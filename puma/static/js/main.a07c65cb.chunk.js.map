{"version":3,"sources":["components/Map.js","App.js","serviceWorker.js","index.js"],"names":["styles","width","height","position","Map","useState","map","setMap","mapContainer","useRef","useEffect","mapboxgl","accessToken","container","current","style","center","zoom","on","resize","addDrawControl","initializeMap","draw","MapboxDraw","displayControlsDefault","controls","point","trash","addControl","updatePoints","points","getAll","features","feat","geometry","coordinates","length","url","join","axios","get","then","res","linestring","data","trips","waypoints","item","location","waypoint_index","getSource","removeLayer","removeSource","addSource","type","addLayer","ref","el","App","className","Boolean","window","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"iOAOMA,EAAS,CACXC,MAAO,QACPC,OAAQ,oBACRC,SAAU,YAyICC,EAtIH,WAAO,IAAD,EACQC,mBAAS,MADjB,mBACPC,EADO,KACFC,EADE,KAIRC,EAAeC,iBAAO,MAE5BC,qBAAU,WACNC,IAASC,YAAc,6FAiBlBN,GAhBiB,SAAC,GAA8B,IAA5BC,EAA2B,EAA3BA,OAAQC,EAAmB,EAAnBA,aACvBF,EAAM,IAAIK,IAASP,IAAI,CACzBS,UAAWL,EAAaM,QACxBC,MAAO,mCACPC,OAAQ,CAAC,SAAU,UACnBC,KAAM,KAGVX,EAAIY,GAAG,QAAQ,WACXX,EAAOD,GACPA,EAAIa,SAEJC,EAAed,MAIbe,CAAc,CAAEd,SAAQC,mBACnC,CAACF,IAEJ,IAAMc,EAAiB,SAACd,GACpB,IAAIgB,EAAO,IAAIC,IAAW,CACtBC,wBAAwB,EACxBC,SAAU,CACNC,OAAO,EACPC,OAAO,GAEXZ,MAAO,KAIXT,EAAIsB,WAAWN,EAAM,YAGrB,IAAMO,EAAe,WACjB,IACIC,EADOR,EAAKS,SACEC,SAAS1B,KAAI,SAAA2B,GAAI,OAAIA,EAAKC,SAASC,eAErD,GAAIL,EAAOM,OAAS,EAAG,CACnB,IAAIC,EAAG,uEAAmEP,EAAOQ,KAAK,KAA/E,oDACPC,IAAMC,IAAIH,GAAKI,MAAK,SAAAC,GAChB,IAAIC,EAAaD,EAAIE,KAAKC,MAAM,GAAGX,SAC/BY,EAAYJ,EAAIE,KAAKE,UAAUxC,KAAI,SAACyC,GAYpC,MAXc,CACV,KAAQ,UACR,SAAY,CACR,KAAQ,QACR,YAAeA,EAAKC,UAExB,WAAc,CACV,GAAMD,EAAKE,eAAgB,OAQnC3C,EAAI4C,UAAU,UAAY5C,EAAI4C,UAAU,eACxC5C,EAAI6C,YAAY,SAChB7C,EAAI8C,aAAa,SACjB9C,EAAI6C,YAAY,aAChB7C,EAAI8C,aAAa,cAGrB9C,EAAI+C,UAAU,QAAS,CACnB,KAAQ,UACR,KAAQ,CACJ,KAAQ,UACR,WAAc,GACd,SAAYV,KAIpBrC,EAAI+C,UAAU,YAAa,CACvB,KAAQ,UACR,KAAQ,CAACC,KAAM,oBAAqBtB,SAAUc,KAGlDxC,EAAIiD,SAAS,CACT,GAAM,QACN,KAAQ,OACR,OAAU,QACV,OAAU,CACN,YAAa,QACb,WAAY,SAEhB,MAAS,CACL,aAAc,kBACd,aAAc,KAItBjD,EAAIiD,SAAS,CACT,GAAM,YACN,KAAQ,SACR,OAAU,YACV,OAAU,CAGN,aAAc,YAEd,aAAc,CAAC,MAAO,MACtB,YAAa,CAAC,qBAAsB,yBACpC,cAAe,CAAC,EAAG,IACnB,cAAe,cAQnCjD,EAAIY,GAAG,cAAeW,GACtBvB,EAAIY,GAAG,cAAeW,GACtBvB,EAAIY,GAAG,cAAeW,IAS1B,OAAO,yBAAK2B,IAAK,SAAAC,GAAE,OAAKjD,EAAaM,QAAU2C,GAAK1C,MAAOf,KCnIhD0D,EARH,WACV,OACE,yBAAKC,UAAU,OACb,kBAAC,EAAD,QCIcC,QACW,cAA7BC,OAAOb,SAASc,UAEe,UAA7BD,OAAOb,SAASc,UAEhBD,OAAOb,SAASc,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAM7B,MAAK,SAAA8B,GACjCA,EAAaC,iB","file":"static/js/main.a07c65cb.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport mapboxgl from \"mapbox-gl\";\nimport MapboxDraw from '@mapbox/mapbox-gl-draw'\nimport \"mapbox-gl/dist/mapbox-gl.css\";\nimport \"@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.css\"\nimport axios from 'axios'\n\nconst styles = {\n    width: \"100vw\",\n    height: \"calc(100vh - 0px)\",\n    position: \"absolute\"\n};\n\nconst Map = () => {\n    const [map, setMap] = useState(null);\n    // const [waypoints, setWaypoints] = useState([]);\n    // const [route, setRoute] = useState({});\n    const mapContainer = useRef(null);\n\n    useEffect(() => {\n        mapboxgl.accessToken = \"pk.eyJ1IjoiYmFmZmlvc28iLCJhIjoiY2s0eHNsbXRoMDQwODNtbzZydGtheWRzayJ9.HRBBcfhegW6-bvmCAfxtvg\";\n        const initializeMap = ({ setMap, mapContainer }) => {\n            const map = new mapboxgl.Map({\n                container: mapContainer.current,\n                style: \"mapbox://styles/mapbox/light-v10\", // stylesheet location\n                center: [12.52489, 55.68168],\n                zoom: 10\n            });\n\n            map.on(\"load\", () => {\n                setMap(map);\n                map.resize();\n\n                addDrawControl(map)\n            });\n        };\n\n        if (!map) initializeMap({ setMap, mapContainer });\n    }, [map]);\n\n    const addDrawControl = (map) => {\n        let draw = new MapboxDraw({\n            displayControlsDefault: false,\n            controls: {\n                point: true,\n                trash: true\n            },\n            style: {\n                // \"circle-radius\": 30\n            }\n        });\n        map.addControl(draw, 'top-left');\n\n        // Get drawn features and add to state\n        const updatePoints = () => {\n            let geom = draw.getAll();\n            let points = geom.features.map(feat => feat.geometry.coordinates)\n\n            if (points.length > 1) {\n                let url = `http://165.22.200.0:5000/trip/v1/driving/12.578769,55.666729;${points.join(';')}?roundtrip=true&geometries=geojson&overview=full`\n                axios.get(url).then(res => {\n                    let linestring = res.data.trips[0].geometry\n                    let waypoints = res.data.waypoints.map((item) => {\n                        let feature = {\n                            'type': 'Feature',\n                            'geometry': {\n                                'type': 'Point',\n                                'coordinates': item.location\n                            },\n                            'properties': {\n                                'id': item.waypoint_index +1\n                            }\n                        }\n\n                        return feature\n                    })\n\n                    // Remove current overlay\n                    if (map.getSource('route') && map.getSource('waypoints')) {\n                        map.removeLayer('route')\n                        map.removeSource('route')\n                        map.removeLayer('waypoints')\n                        map.removeSource('waypoints')\n                    }\n\n                    map.addSource(\"route\", {\n                        \"type\": \"geojson\",\n                        \"data\": {\n                            'type': 'Feature',\n                            'properties': {},\n                            'geometry': linestring\n                        }\n                    });\n\n                    map.addSource(\"waypoints\", {\n                        \"type\": \"geojson\",\n                        \"data\": {type: \"FeatureCollection\", features: waypoints}\n                    });\n\n                    map.addLayer({\n                        'id': 'route',\n                        'type': 'line',\n                        'source': 'route',\n                        'layout': {\n                            'line-join': 'round',\n                            'line-cap': 'round'\n                        },\n                        'paint': {\n                            'line-color': 'rgb(22,200,200)',\n                            'line-width': 4\n                        }\n                    })\n\n                    map.addLayer({\n                        'id': 'waypoints',\n                        'type': 'symbol',\n                        'source': 'waypoints',\n                        'layout': {\n                            // get the icon name from the source's \"icon\" property\n                            // concatenate the name to get an icon from the style's sprite sheet\n                            'icon-image': 'harbor-15',\n                            // get the title name from the source's \"title\" property\n                            'text-field': ['get', 'id'],\n                            'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],\n                            'text-offset': [0, 0.6],\n                            'text-anchor': 'top'\n                        }\n                    })\n                })\n            }\n        }\n\n        // Store drawn poygon in state\n        map.on('draw.create', updatePoints);\n        map.on('draw.update', updatePoints);\n        map.on('draw.delete', updatePoints);\n    }\n\n    // const getTrip = waypoints => {\n    //     let url = `http://165.22.200.0:5000/route/v1/trip/${waypoints}?steps=false&geometries=geojson&overview=full&annotations=false`\n    //     return axios.get(url).then(req => setRoute(req.data.routes[0].geometry))\n    // }\n\n\n    return <div ref={el => (mapContainer.current = el)} style={styles} />;\n};\n\nexport default Map;","import React from 'react';\nimport './App.css';\n\nimport Map from './components/Map'\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <Map></Map>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}